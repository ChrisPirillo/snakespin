<!DOCTYPE html>
<html lang="en"><head><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-1CQ4D3VQ3L"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-1CQ4D3VQ3L');
  </script>

<meta charset="UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<title>Snakespin: 3D Gyroid Art Generator</title>

<meta name="description" content="Generate stunning 3D mathematical art with the Snakespin raymarching engine. Fully customize colors, lighting, and scales for high-res wallpaper export.">
<meta name="keywords" content="WebGL, Raymarching, Gyroid, Generative Art, 3D Visualization, Interactive Art, Shader Art, 4K Wallpaper">
<meta name="author" content="Chris Pirillo">
<meta name="robots" content="index, follow">
<meta name="theme-color" content="#0f172a">

<meta property="og:site_name" content="Chris Pirillo's Arcade">
<meta property="og:type" content="website">
<meta property="og:title" content="Snakespin: 3D Gyroid Art Generator">
<meta property="og:description" content="Generate stunning 3D mathematical art with the Snakespin raymarching engine. Fully customize colors, lighting, and scales for high-res wallpaper export.">
<meta property="og:url" content="https://pirillo.com/arcade/snakespin.html">
<meta property="og:image" content="https://pirillo.com/arcade/images/snakespin.png">
<meta property="og:image:alt" content="Snakespin: 3D Gyroid Art Generator">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@ChrisPirillo">
<meta name="twitter:creator" content="@ChrisPirillo">
<meta name="twitter:title" content="Snakespin: 3D Gyroid Art Generator">
<meta name="twitter:description" content="Generate stunning 3D mathematical art with the Snakespin raymarching engine. Fully customize colors, lighting, and scales for high-res wallpaper export.">
<meta name="twitter:image" content="https://pirillo.com/arcade/images/snakespin.png">
<meta name="twitter:domain" content="pirillo.com">

<link rel="canonical" href="https://pirillo.com/arcade/snakespin.html">

<script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "WebPage",
  "name": "Snakespin: 3D Gyroid Art Generator",
  "description": "Generate stunning 3D mathematical art with the Snakespin raymarching engine. Fully customize colors, lighting, and scales for high-res wallpaper export.",
  "keywords": "WebGL, Raymarching, Gyroid, Generative Art, 3D Visualization, Interactive Art, Shader Art, 4K Wallpaper",
  "url": "https://pirillo.com/arcade/snakespin.html",
  "image": "https://pirillo.com/arcade/images/snakespin.png",
  "primaryImageOfPage": {
    "@type": "ImageObject",
    "url": "https://pirillo.com/arcade/images/snakespin.png"
  },
  "author": {
    "@type": "Person",
    "name": "Chris Pirillo",
    "url": "https://pirillo.com",
    "sameAs": [
      "https://x.com/ChrisPirillo"
    ]
  },
  "mainEntity": {
    "name": "Snakespin: 3D Gyroid Art Generator",
    "description": "Generate stunning 3D mathematical art with the Snakespin raymarching engine. Fully customize colors, lighting, and scales for high-res wallpaper export.",
    "image": "https://pirillo.com/arcade/images/snakespin.png",
    "operatingSystem": "Web Browser",
    "author": {
      "@type": "Person",
      "name": "Chris Pirillo"
    },
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD",
      "availability": "https://schema.org/InStock"
    },
    "@type": "WebApplication",
    "applicationCategory": "Simulation"
  }
}</script>

<meta charset="UTF-8">
<script src="https://cdn.tailwindcss.com"></script>
<style>body { margin: 0; overflow: hidden; background: #000; color: #fff; user-select: none; -webkit-user-select: none; font-family: ui-sans-serif, system-ui, sans-serif; }
canvas { display: block; width: 100vw; height: 100vh; touch-action: none; }
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); }
::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.4); }
input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: #fff; cursor: pointer; margin-top: -6px; }
input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #4b5563; border-radius: 2px; }
input[type=color] { -webkit-appearance: none; border: none; width: 32px; height: 32px; border-radius: 4px; cursor: pointer; padding: 0; background: transparent; }
input[type=color]::-webkit-color-swatch-wrapper { padding: 0; }
input[type=color]::-webkit-color-swatch { border: 1px solid #4b5563; border-radius: 4px; }
.glass-panel { background: rgba(17, 24, 39, 0.85); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); border-right: 1px solid rgba(255,255,255,0.1); }
.fade-transition { transition: opacity 0.3s ease, visibility 0.3s ease; }
.slide-transition { transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); }</style>
</head>
<body>

<canvas id="glcanvas"></canvas>

<!-- UI Layer -->
<div id="ui-layer" class="fixed inset-0 pointer-events-none flex z-50">
    
    <!-- Hamburger Trigger -->
    <button id="menu-btn" class="pointer-events-auto absolute top-4 left-4 p-3 bg-gray-900/60 hover:bg-gray-800/80 backdrop-blur rounded-lg border border-gray-700 transition-colors z-50">
        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
    </button>

    <!-- Overlay to close menu -->
    <div id="menu-overlay" class="pointer-events-auto absolute inset-0 bg-black/20 opacity-0 invisible fade-transition"></div>

    <!-- Settings Panel -->
    <div id="settings-panel" class="pointer-events-auto absolute top-0 left-0 w-80 max-w-[85vw] h-full glass-panel flex flex-col transform -translate-x-full slide-transition z-50 shadow-2xl">
        
        <!-- Sticky Header -->
        <div class="sticky top-0 bg-gray-900 border-b border-gray-700 px-4 py-4 flex justify-between items-center z-10">
            <h1 class="text-lg font-bold tracking-wide">SNAKESPIN</h1>
            <div class="flex items-center gap-2">
                <button id="info-btn" class="text-gray-400 hover:text-white transition-colors" title="Info">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                </button>
                <button id="close-btn" class="text-gray-400 hover:text-white transition-colors p-1" title="Close">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
        </div>

        <!-- Scrollable Body for Controls -->
        <div id="controls-container" class="flex-1 overflow-y-auto p-4 space-y-5 pb-24">
            <!-- Controls injected here via JS -->
        </div>

        <!-- Sticky Footer Actions -->
        <div class="absolute bottom-0 left-0 right-0 p-4 bg-gray-900 border-t border-gray-700 flex flex-col gap-2 z-10">
            <div class="flex gap-2">
                <button id="btn-randomize" class="flex-1 bg-indigo-600 hover:bg-indigo-500 text-sm font-semibold py-2 rounded transition-colors">Randomize</button>
                <button id="btn-reset" class="flex-1 bg-gray-700 hover:bg-gray-600 text-sm font-semibold py-2 rounded transition-colors">Defaults</button>
            </div>
            <button id="btn-export-4k" class="w-full bg-emerald-600 hover:bg-emerald-500 text-sm font-semibold py-2 rounded transition-colors">Export 4K Wallpaper</button>
            <div class="flex gap-2 text-xs text-gray-400 mt-1">
                <button id="btn-export-settings" class="flex-1 hover:text-white text-left">Export Settings</button>
                <button id="btn-import-settings" class="flex-1 hover:text-white text-right">Import Settings</button>
                <input type="file" id="file-import" accept=".json" class="hidden">
            </div>
        </div>
    </div>
</div>

<!-- Info Modal -->
<div id="info-modal" class="fixed inset-0 pointer-events-none z-[60] flex items-center justify-center opacity-0 invisible fade-transition">
    <div class="absolute inset-0 bg-black/60 pointer-events-auto" id="info-overlay"></div>
    <div class="bg-gray-900 border border-gray-700 rounded-xl p-6 max-w-sm w-full mx-4 relative pointer-events-auto shadow-2xl transform scale-95 transition-transform duration-300" id="info-content">
        <button id="info-close" class="absolute top-4 right-4 text-gray-400 hover:text-white"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button>
        <h2 class="text-xl font-bold mb-1">Snakespin</h2>
        <p class="text-xs text-indigo-400 font-semibold tracking-wide mb-4">Formula credit: tubeman</p>
        <p class="text-gray-300 text-sm mb-6 leading-relaxed">
            A real-time WebGL raymarching engine. Interact via mouse drag/scroll or touch drag/pinch.
            Double-tap or click empty space to randomize.<br><br>
            Designed for seamless state manipulation and high-res rendering.
        </p>
        <div class="flex flex-col gap-3">
            <a href="https://pirillo.com/arcade/" target="_blank" rel="noopener noreferrer" class="bg-gray-800 hover:bg-gray-700 py-2 px-4 rounded text-center text-sm font-semibold transition-colors">More Apps</a>
            <a href="https://chris.pirillo.com/" target="_blank" rel="noopener noreferrer" class="bg-gray-800 hover:bg-gray-700 py-2 px-4 rounded text-center text-sm font-semibold transition-colors">Follow Chris</a>
            <a href="https://ctrlaltcreate.live/" target="_blank" rel="noopener noreferrer" class="bg-gray-800 hover:bg-gray-700 py-2 px-4 rounded text-center text-sm font-semibold transition-colors">Learn More</a>
        </div>
    </div>
</div>

<script>
// --- SHADERS ---
const vsSource = `#version 300 es
in vec4 aVertexPosition;
void main() { gl_Position = aVertexPosition; }`;

const fsSource = `#version 300 es
precision highp float;

uniform vec2 iResolution;
uniform float iTime;
uniform vec2 u_pan;

uniform float u_far;
uniform int u_rm_iter;
uniform float u_fog_density;
uniform float u_gyroid_scale;
uniform float u_gyroid_offset;
uniform float u_speed;
uniform float u_zoom;
uniform vec3 u_col_mat1;
uniform vec3 u_col_mat2;
uniform vec3 u_col_light1;
uniform vec3 u_col_light2;
uniform vec3 u_col_light3;
uniform vec3 u_col_spec;
uniform float u_ao_strength;
uniform float u_fade;

out vec4 fragColor;

#define PI 3.14159265

int m = 0;

mat2 rot(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }
mat3 lookAt(vec3 dir) {
    vec3 up=vec3(0.,1.,0.);
    vec3 rt=normalize(cross(dir,up));
    return mat3(rt, cross(rt,dir), dir);
}

float gyroid(vec3 p) { return dot(cos(p), sin(p.zxy)) + u_gyroid_offset; }

float map(vec3 p) {
    float r = 1e5, d;
    p *= u_gyroid_scale;
    
    d = gyroid(p) / u_gyroid_scale;
    if (d<r) { r=d; m=1; }
    
    d = gyroid(p - vec3(0,0,PI)) / u_gyroid_scale;
    if (d<r) { r=d; m=2; }
    
    return r;
}

float raymarch(vec3 ro, vec3 rd) {
    float t = 0.;
    for (int i=0; i<300; i++) {
        if (i >= u_rm_iter) break;
        float d = map(ro + rd*t);
        if (abs(d) < .001) break;
        t += d;
        if (t > u_far) break;
    }
    return t;
}

float getAO(vec3 p, vec3 sn){
    float occ = 0.;
    for (float i=0.; i<4.; i++) {
        float t = i*.08;        
        float d = map(p + sn*t);
        occ += t-d;
    }
    return clamp(1. - occ * u_ao_strength, 0., 1.);    
}

vec3 getNormal(vec3 p){
    vec2 e = vec2(0.5773,-0.5773)*0.001;
    return normalize(e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) + e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));
}

vec3 trace(vec3 ro, vec3 rd) {   
    vec3 C = vec3(0);
    vec3 throughput = vec3(1);
    
    for (int bounce = 0; bounce < 2; bounce++) {
        float d = raymarch(ro, rd);
        if (d > u_far) { break; }

        float fog = 1. - exp(-u_fog_density*d*d);
        C += throughput * fog * vec3(0); 
        throughput *= 1. - fog;        
        
        vec3 p = ro + rd*d;
        vec3 sn = normalize(getNormal(p) + pow(abs(cos(p*64.)), vec3(16))*.1);

        vec3 lp = vec3(10.,-10.,-10.+ro.z);
        vec3 ld = normalize(lp - p);
        float diff = max(0., .5+2.*dot(sn, ld));
        float diff2 = pow(length(sin(sn*2.)*.5+.5), 2.);
        float diff3 = max(0., .5+.5*dot(sn, vec2(1,0).yyx));
        
        float spec = max(0., dot(reflect(-ld, sn), -rd));
        float fres = 1. - max(0.,dot(-rd, sn));
        vec3 col = vec3(0), alb = vec3(0);
        
        col += u_col_light1 * diff;
        col += u_col_light2 * diff2;
        col += u_col_light3 * diff3; 
        col += u_col_spec * pow(spec,4.)*8.;
        
        float freck = dot(cos(p*23.),vec3(1));
        if (m==1) { alb = u_col_mat1;  alb *= max(.6, step(2.5, freck)); }
        if (m==2) { alb = u_col_mat2;  alb *= max(.8, step(-2.5, freck)); }
        col *= alb;
        
        col *= getAO(p, sn);
        C += throughput * col;
            
        rd = reflect(rd, sn);
        ro = p + sn*.01;
        throughput *=  .9 * pow(fres, 1.);
    }
    return C;
}

void main() {
    vec2 uv = (gl_FragCoord.xy - iResolution.xy*.5) / iResolution.y;

    float t = iTime * u_speed;
    vec3 ro = vec3(PI/2.,0, -t*.5);
    vec3 rd = normalize(vec3(uv, -0.5 * u_zoom));

    // Base auto-movement
    rd.xy = rot(sin(t*.2)) * rd.xy;
    vec3 ta = vec3(cos(t*.4), sin(t*.4), 4.);
    rd = lookAt(normalize(ta)) * rd;
    
    // Apply user panning overlay
    rd.zy = rot(u_pan.y) * rd.zy;
    rd.xz = rot(u_pan.x) * rd.xz;
    
    vec3 col = trace(ro, rd);
    
    col *= smoothstep(0.,1., 1.2-length(uv*.9));
    col = pow(col, vec3(0.4545));
    col *= u_fade;
    
    fragColor = vec4(col, 1.0);
}`;

// --- CONFIG & STATE ---
const CONFIG = [
    { id: 'speed', label: 'Animation Speed', type: 'range', min: 0, max: 2.0, step: 0.1, def: 1.0 },
    { id: 'zoom', label: 'Camera FOV/Zoom', type: 'range', min: 0.2, max: 3, step: 0.1, def: 1.0 },
    { id: 'gyroidScale', label: 'Gyroid Scale', type: 'range', min: 0.5, max: 3.0, step: 0.1, def: 1.0 },
    { id: 'gyroidOffset', label: 'Gyroid Offset', type: 'range', min: 0.0, max: 1.2, step: 0.1, def: 1.0 },
    { id: 'rmIter', label: 'Raymarch Precision', type: 'range', min: 50, max: 250, step: 1, def: 150 },
    { id: 'far', label: 'View Distance', type: 'range', min: 10, max: 60, step: 1, def: 30 },
    { id: 'fogDensity', label: 'Fog Density', type: 'range', min: 0.0, max: 0.05, step: 0.001, def: 0.008 },
    { id: 'aoStrength', label: 'AO Strength', type: 'range', min: 0.0, max: 2.0, step: 0.1, def: 1.0 },
    { id: 'autoAdvance', label: 'Auto-Advance (sec, 0=Off)', type: 'range', min: 0, max: 60, step: 1, def: 0 },
    { id: 'colMat1', label: 'Material 1 Color', type: 'color', def: '#3319e5' },
    { id: 'colMat2', label: 'Material 2 Color', type: 'color', def: '#994c19' },
    { id: 'colLight1', label: 'Light 1 Color', type: 'color', def: '#6699e5' },
    { id: 'colLight2', label: 'Light 2 Color', type: 'color', def: '#7f1919' },
    { id: 'colLight3', label: 'Light 3 Color', type: 'color', def: '#e51966' },
    { id: 'colSpec', label: 'Specular Color', type: 'color', def: '#4c3f3f' }
];

let state = {};
let fadeValue = 1.0;
let transitionState = 0; // 0: IDLE, 1: FADE OUT, 2: FADE IN
let autoAdvanceTimer = 0;
let lastTime = 0;

function hexToRgb(hex) {
    const bigint = parseInt(hex.slice(1), 16);
    return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255].map(x => x / 255);
}
function rgbToHex(r, g, b) {
    return "#" + (1 << 24 | Math.round(r*255) << 16 | Math.round(g*255) << 8 | Math.round(b*255)).toString(16).slice(1);
}

function initDefaults() {
    CONFIG.forEach(c => state[c.id] = c.def);
}
initDefaults();

function randomizeState() {
    state.speed = 0.2 + Math.random() * 1.8;
    state.zoom = 0.5 + Math.random() * 1.5;
    state.gyroidScale = 0.7 + Math.random() * 1.5;
    state.gyroidOffset = Math.random() * 1.2;
    state.fogDensity = 0.002 + Math.random() * 0.02;
    state.colMat1 = rgbToHex(Math.random(), Math.random(), Math.random());
    state.colMat2 = rgbToHex(Math.random(), Math.random(), Math.random());
    state.colLight1 = rgbToHex(Math.random(), Math.random(), Math.random());
    state.colLight2 = rgbToHex(Math.random(), Math.random(), Math.random());
    state.colLight3 = rgbToHex(Math.random(), Math.random(), Math.random());
    updateUIFromState();
}

function triggerFadeSwapFade() {
    if (transitionState !== 0) return;
    transitionState = 1; // Start fade out
    autoAdvanceTimer = 0;
}

// --- WEBGL SETUP ---
const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl2', { preserveDrawingBuffer: true, antialias: false });
if (!gl) alert("WebGL 2 not supported. Please use a modern browser.");

function compileShader(type, source) {
    const s = gl.createShader(type);
    gl.shaderSource(s, source);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        console.error("Shader compile error:", gl.getShaderInfoLog(s));
        gl.deleteShader(s);
        return null;
    }
    return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, compileShader(gl.VERTEX_SHADER, vsSource));
gl.attachShader(prog, compileShader(gl.FRAGMENT_SHADER, fsSource));
gl.linkProgram(prog);
if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) console.error("Link error:", gl.getProgramInfoLog(prog));
gl.useProgram(prog);

const posBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);
const posLoc = gl.getAttribLocation(prog, "aVertexPosition");
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

const locs = {
    iRes: gl.getUniformLocation(prog, "iResolution"),
    iTime: gl.getUniformLocation(prog, "iTime"),
    uPan: gl.getUniformLocation(prog, "u_pan"),
    fade: gl.getUniformLocation(prog, "u_fade"),
    speed: gl.getUniformLocation(prog, "u_speed"),
    zoom: gl.getUniformLocation(prog, "u_zoom"),
    far: gl.getUniformLocation(prog, "u_far"),
    rmIter: gl.getUniformLocation(prog, "u_rm_iter"),
    fogDensity: gl.getUniformLocation(prog, "u_fog_density"),
    gyroidScale: gl.getUniformLocation(prog, "u_gyroid_scale"),
    gyroidOffset: gl.getUniformLocation(prog, "u_gyroid_offset"),
    aoStrength: gl.getUniformLocation(prog, "u_ao_strength"),
    colMat1: gl.getUniformLocation(prog, "u_col_mat1"),
    colMat2: gl.getUniformLocation(prog, "u_col_mat2"),
    colLight1: gl.getUniformLocation(prog, "u_col_light1"),
    colLight2: gl.getUniformLocation(prog, "u_col_light2"),
    colLight3: gl.getUniformLocation(prog, "u_col_light3"),
    colSpec: gl.getUniformLocation(prog, "u_col_spec"),
};

// --- INTERACTION ---
let isDragging = false;
let globalTime = 0;
let pointers = new Map();
let initialPinchDist = null;
let initialZoom = 1.0;

// Camera state
let userYaw = 0.0;
let userPitch = 0.0;
let lastX = 0, lastY = 0;
let dragDist = 0;
let lastTapTime = 0;

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener('resize', resize);
resize();

// Input handling (Canvas)
canvas.addEventListener('pointerdown', e => {
    pointers.set(e.pointerId, e);
    
    if (pointers.size === 1) {
        const now = performance.now();
        if (e.pointerType === 'touch' && (now - lastTapTime < 300)) {
            triggerFadeSwapFade(); // Mobile double tap
        }
        lastTapTime = now;
        
        isDragging = true;
        lastX = e.clientX; 
        lastY = e.clientY;
        dragDist = 0;
    } else if (pointers.size === 2) {
        isDragging = false; // switch to pinch
        const pts = Array.from(pointers.values());
        initialPinchDist = Math.hypot(pts[0].clientX - pts[1].clientX, pts[0].clientY - pts[1].clientY);
        initialZoom = state.zoom;
    }
});

canvas.addEventListener('pointermove', e => {
    if (!pointers.has(e.pointerId)) return;
    pointers.set(e.pointerId, e);

    if (pointers.size === 1 && isDragging) {
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        
        userYaw -= dx * 0.005;
        userPitch -= dy * 0.005;
        // Keep pitch from flipping
        userPitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, userPitch));
        
        dragDist += Math.abs(dx) + Math.abs(dy);
        lastX = e.clientX;
        lastY = e.clientY;
    } else if (pointers.size === 2) {
        const pts = Array.from(pointers.values());
        const dist = Math.hypot(pts[0].clientX - pts[1].clientX, pts[0].clientY - pts[1].clientY);
        if (initialPinchDist) {
            // Inverse scale for zoom (pinch out = lower FOV number)
            const scale = initialPinchDist / dist;
            state.zoom = Math.max(0.2, Math.min(3.0, initialZoom * scale));
            updateUIFromState();
        }
    }
});

function pointerEnd(e) {
    pointers.delete(e.pointerId);
    
    // Desktop single click (no drag)
    if (e.pointerType === 'mouse' && isDragging && dragDist < 5) {
        triggerFadeSwapFade();
    }

    if (pointers.size === 0) {
        isDragging = false;
        initialPinchDist = null;
    } else if (pointers.size === 1) {
        // Reset drag to remaining pointer
        const ptr = Array.from(pointers.values())[0];
        lastX = ptr.clientX;
        lastY = ptr.clientY;
        isDragging = true;
        initialPinchDist = null;
    }
}

canvas.addEventListener('pointerup', pointerEnd);
canvas.addEventListener('pointercancel', pointerEnd);
canvas.addEventListener('pointerleave', pointerEnd);

window.addEventListener('wheel', e => {
    if (e.target !== canvas) return;
    state.zoom += e.deltaY * 0.001;
    state.zoom = Math.max(0.2, Math.min(3.0, state.zoom));
    updateUIFromState();
}, {passive: true});

// --- UI LOGIC ---
const uiContainer = document.getElementById('controls-container');

CONFIG.forEach(c => {
    const wrap = document.createElement('div');
    if (c.type === 'range') {
        wrap.className = 'flex flex-col gap-1';
        wrap.innerHTML = `
            <div class="flex justify-between text-xs font-semibold text-gray-300">
                <label for="${c.id}">${c.label}</label>
                <span id="val-${c.id}">${c.def}</span>
            </div>
            <input type="range" id="${c.id}" min="${c.min}" max="${c.max}" step="${c.step}" value="${c.def}">
        `;
    } else if (c.type === 'color') {
        wrap.className = 'flex justify-between items-center text-xs font-semibold text-gray-300';
        wrap.innerHTML = `
            <label for="${c.id}">${c.label}</label>
            <input type="color" id="${c.id}" value="${c.def}">
        `;
    }
    uiContainer.appendChild(wrap);

    const input = document.getElementById(c.id);
    input.addEventListener('input', e => {
        let val = c.type === 'range' ? parseFloat(e.target.value) : e.target.value;
        state[c.id] = val;
        if (c.type === 'range') document.getElementById(`val-${c.id}`).innerText = val.toFixed(c.step < 1 ? (c.step < 0.1 ? 3 : 1) : 0);
    });
});

function updateUIFromState() {
    CONFIG.forEach(c => {
        const input = document.getElementById(c.id);
        if (c.type === 'range') {
            input.value = state[c.id];
            document.getElementById(`val-${c.id}`).innerText = state[c.id].toFixed(c.step < 1 ? (c.step < 0.1 ? 3 : 1) : 0);
        } else if (c.type === 'color') {
            input.value = state[c.id];
        }
    });
}

// Menu interactions
const menuBtn = document.getElementById('menu-btn');
const closeBtn = document.getElementById('close-btn');
const settingsPanel = document.getElementById('settings-panel');
const menuOverlay = document.getElementById('menu-overlay');

function toggleMenu(show) {
    if (show) {
        settingsPanel.classList.remove('-translate-x-full');
        menuOverlay.classList.remove('opacity-0', 'invisible');
        menuOverlay.classList.add('opacity-100');
    } else {
        settingsPanel.classList.add('-translate-x-full');
        menuOverlay.classList.remove('opacity-100');
        menuOverlay.classList.add('opacity-0');
        setTimeout(() => { if(settingsPanel.classList.contains('-translate-x-full')) menuOverlay.classList.add('invisible'); }, 300);
    }
}

menuBtn.addEventListener('click', () => toggleMenu(true));
closeBtn.addEventListener('click', () => toggleMenu(false));
menuOverlay.addEventListener('click', () => toggleMenu(false));

// Info Modal interactions
const infoBtn = document.getElementById('info-btn');
const infoModal = document.getElementById('info-modal');
const infoClose = document.getElementById('info-close');
const infoOverlay = document.getElementById('info-overlay');
const infoContent = document.getElementById('info-content');

function toggleInfo(show) {
    if (show) {
        infoModal.classList.remove('opacity-0', 'invisible');
        infoContent.classList.remove('scale-95');
        infoContent.classList.add('scale-100');
    } else {
        infoModal.classList.add('opacity-0');
        infoContent.classList.remove('scale-100');
        infoContent.classList.add('scale-95');
        setTimeout(() => infoModal.classList.add('invisible'), 300);
    }
}
infoBtn.addEventListener('click', () => toggleInfo(true));
infoClose.addEventListener('click', () => toggleInfo(false));
infoOverlay.addEventListener('click', () => toggleInfo(false));

document.addEventListener('keydown', e => {
    if (e.key === 'Escape') {
        if (!infoModal.classList.contains('invisible')) toggleInfo(false);
        else toggleMenu(false);
    }
});

// Action Buttons
document.getElementById('btn-randomize').addEventListener('click', triggerFadeSwapFade);
document.getElementById('btn-reset').addEventListener('click', () => { initDefaults(); updateUIFromState(); userYaw=0; userPitch=0; });

document.getElementById('btn-export-4k').addEventListener('click', () => {
    const oldW = canvas.width, oldH = canvas.height;
    // 4K UHD
    canvas.width = 3840; canvas.height = 2160;
    gl.viewport(0, 0, 3840, 2160);
    
    // Sync render
    renderFrame(0);
    
    const dataUrl = canvas.toDataURL("image/png");
    const a = document.createElement('a');
    a.href = dataUrl;
    a.download = `Snakespin_4K_${new Date().toISOString().slice(0,10)}.png`;
    a.click();
    
    // Restore
    canvas.width = oldW; canvas.height = oldH;
    gl.viewport(0, 0, oldW, oldH);
});

document.getElementById('btn-export-settings').addEventListener('click', () => {
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(state));
    const a = document.createElement('a');
    a.href = dataStr;
    a.download = `Snakespin_Settings_${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
    a.click();
});

document.getElementById('btn-import-settings').addEventListener('click', () => document.getElementById('file-import').click());
document.getElementById('file-import').addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = e => {
        try {
            const json = JSON.parse(e.target.result);
            Object.assign(state, json);
            updateUIFromState();
        } catch (err) { alert("Invalid settings file."); }
    };
    reader.readAsText(file);
});


// --- RENDER LOOP ---
function renderFrame(time) {
    const dt = (time - lastTime) / 1000;
    lastTime = time;
    
    if (dt > 0 && dt < 0.2) {
        globalTime += dt * state.speed;
        
        // Transitions
        if (transitionState === 1) { // fading out
            fadeValue -= dt * 3.0; 
            if (fadeValue <= 0) {
                fadeValue = 0;
                randomizeState();
                transitionState = 2;
            }
        } else if (transitionState === 2) { // fading in
            fadeValue += dt * 3.0;
            if (fadeValue >= 1) {
                fadeValue = 1;
                transitionState = 0;
            }
        }

        // Auto Advance
        if (state.autoAdvance > 0 && transitionState === 0) {
            autoAdvanceTimer += dt;
            if (autoAdvanceTimer >= state.autoAdvance) {
                triggerFadeSwapFade();
            }
        }
    }

    gl.uniform2f(locs.iRes, canvas.width, canvas.height);
    gl.uniform1f(locs.iTime, globalTime);
    gl.uniform2f(locs.uPan, userYaw, userPitch);
    gl.uniform1f(locs.fade, fadeValue);

    gl.uniform1f(locs.speed, state.speed);
    gl.uniform1f(locs.zoom, state.zoom);
    gl.uniform1f(locs.far, state.far);
    gl.uniform1i(locs.rmIter, state.rmIter);
    gl.uniform1f(locs.fogDensity, state.fogDensity);
    gl.uniform1f(locs.gyroidScale, state.gyroidScale);
    gl.uniform1f(locs.gyroidOffset, state.gyroidOffset);
    gl.uniform1f(locs.aoStrength, state.aoStrength);
    
    gl.uniform3fv(locs.colMat1, hexToRgb(state.colMat1));
    gl.uniform3fv(locs.colMat2, hexToRgb(state.colMat2));
    gl.uniform3fv(locs.colLight1, hexToRgb(state.colLight1));
    gl.uniform3fv(locs.colLight2, hexToRgb(state.colLight2));
    gl.uniform3fv(locs.colLight3, hexToRgb(state.colLight3));
    gl.uniform3fv(locs.colSpec, hexToRgb(state.colSpec));

    gl.drawArrays(gl.TRIANGLES, 0, 6);
}

function loop(time) {
    renderFrame(time);
    requestAnimationFrame(loop);
}

// Initial Randomize and Start
randomizeState();
requestAnimationFrame(time => { lastTime = time; loop(time); });

</script>

</body></html>